# 考前总结一下c++的坑  
### 一些不可思议的头文件
  
`memset`函数的头文件是`string.h`。  
另外`memset`函数的第二个参数是内存填充值（以字节为单位），第三个参数是长度。`memset`一般只用作清零。  
  
`std::pair`被定义在`#include <utility>`中，同时，在`#include <map>`中也包含了`utility`。  
  
### 数组初始化
  
数组初始化直接用循环去赋值就可以了。如果要初始化为0的话，可以用`int a[100] = {0};`，但要注意的是，这个操作的逻辑是这样的：  
首先，当初始化列表中值的数量少于数组长度时，编译器会自动将剩下的填充为0，所以前面这么做相当于指定了a[0]的值为0，剩下的被自动填充为0了。所以如果写成`int a[100] = {1};`的话，并不是所有值都初始化为1了，而是a[0]为1，剩余为0。这个要注意。所以全部初始化为1的话，还是得用循环。  
  
另外，二维数组可以像一维数组那样初始化和访问，实际上二维数组在内存中就是按行存放被映射为一维。  

### 小顶堆的构建
  
大顶堆可以直接写成默认形式的
```
std::priority_queue<int> q;
```
但小顶堆的话得指定容器
```
std::priority_queue<int, std::vector<int>, std::greater<int> > q
```
另外，greater和less都定义在头文件`#include <functional>`中。  
  
### vector的操作函数  
  
```
a.push_back(5); // 在a的最后一个向量后插入一个元素，其值为5
a.pop_back(); // 删除a向量的最后一个元素
a.empty(); // 判断a是否为空，空则返回ture,不空则返回false
a.erase(a.begin()); // 删除一个元素
a.size(); //返回a中元素的个数；
```
  
### queue的操作函数  
  
队列创建：queue <int> queue1;  
  
（这里的int可以是各种类型，包括结构体类型）  
  
加入队列：queue1.push(x);  
  
（将x添加到队列的末尾）  
  
弹出队列：queue1.pop();  
  
（弹出队列的第一个元素） 
  
访问队尾元素：queue1.back();  
  
判断队列空：queue1.empty(); 

（当队列空时，返回true） 

查看队列中的元素个数：queue1.size();  
  
**优先队列priority_queue的函数名是一样的**  
  
### scanf vs cin, printf vs cout
  
数据量大时一定要用scanf代替cin，用printf代替cout，这样能够节省等待缓冲区满的时间。  
  
用scanf输入string时，要注意以char数组作为缓存：  
```
char tmp[101];
scanf("%100s", tmp);
string a= tmp;
```
  
用printf输出string：  
```
printf("Follow this command: %s", myString.c_str());
```
  
**但绝不推荐将scanf、printf与string搭配使用！**
  
